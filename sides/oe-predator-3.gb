#side OE-Predator 3
#author oehpr
#seed 1
#color 746
#type Predator
#hardware
	processor 13 0
	robot-sensor 12
	blaster 17 11 12
	engine .14
	energy 300 40
	solar-cells .02
	armor 220
	food-sensor 5 1
	constructor 0.8
	eater 1.1
#decoration 999 x
#code
#const jink-period 3
#const wander-time 12
#const construction-gap 120
#const territory-factor 40

#vector dest
#vector jink 0 0
#var prev-armor
#var damaged 0
#var engage-dist
#var jink-timer 0

new-dest:
	1 vread                          ; territory center
	2dup position v-                 ; difference from center
	1 type-population vs/            ; move territory by portion of pop
	v- 2dup 1 vwrite
	1 type-population territory-factor * sqrt      ; territory radius
	random-angle
	polar-to-rect
	v+
	swap world-width 3 - min 3 max
	swap world-height 3 - min 3 max

	dest!
	return

wait: ;<time>
	do
		sync sync sync sync
	1 - dup while-loop drop
	return

nav: ;<aggression> <target>
	position v-
	velocity 10 vs* v-
	2dup engine-velocity!
	norm * engine-power!
	return

con-logic:
  1 constructor-type!
  energy max-energy - construction-gap +
  energy constructor-remaining - 15 - ; if I can get this baby done, I should do it.
  max constructor-rate!
  return

#start

armor prev-armor!

blaster-range 2 - engage-dist!
position 1 vwrite
new-dest^

; States
wander:
	con-logic^
	new-dest^
	dest position v- engine-velocity!
	0.3 engine-power!
	wander-time wait
	seek& jump

seek:
	energy 5 < if
		0 engine-power!
		15 wait^
	then
	con-logic^
	dest position v- engine-velocity!
	0.03 engine-power!

	prev-armor armor > damaged!
	armor prev-armor!
	damaged attack& ifg

	30 periodic-food-sensor drop
	food-found defend& ifg

	80 periodic-robot-sensor drop
	robot-found attack& ifg

	prev-armor armor > damaged!
	armor prev-armor!
	damaged wander& ifg

	sync sync
	dest position dist 5 > seek& ifg

	new-dest^
	seek& jump

defend:
	con-logic^
	0.1 food-position nav^

	prev-armor armor > damaged!
	armor prev-armor!
	damaged attack& ifg

	food-position position dist 1 <
	eaten not and seek& ifg

	robot-found not 60 * blaster-reload-time +
	periodic-robot-sensor robot-found and if
		1 vread robot-position dist ; how deep target is in territory
		1 type-population 40 * sqrt ; how large territory is
		< attack& ifg
		robot-position robot-velocity lead-blaster
	then

	friendly-collision 0 > wander& ifg

	defend& jump


attack:
	0 constructor-rate!
	energy 50 < runaway& ifg

	robot-position position v-
	2dup unitize engage-dist vs* v-    ; keep some distance
	robot-velocity 7 vs* v+ ; compensate for target velocity
	velocity 7 vs* v-       ; compensate for our velocity
	jink v+                  ; random dodge vector
	2dup engine-velocity!
	norm 0.3 * engine-power!
	sync

	blaster-reload-time periodic-robot-sensor if
		robot-found seek& nifg
		robot-position robot-velocity lead-blaster
		robot-position dest! ; check out the corpse when it dies
	then

	robot-found wander& nifg

	jink-timer nif ; jink calcs. Basically, go left or go right randomly.
		1.5 ; thrust power
		0.5 random-bool pi * pi/2 - ; -90 or +90
		robot-direction +
		polar-to-rect jink!
		jink-period jink-timer!
	then
	jink-timer 1 - jink-timer!

	attack& jump

runaway: ;crap crap crap
	0 constructor-rate!
	1 1 vread nav
	10 wait^
	seek& jump

seek jump
#end
